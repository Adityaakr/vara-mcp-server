/**
 * TypeScript client code generator for Vara programs
 * 
 * This generates a minimal but compilable TypeScript client
 * that can interact with a deployed Vara program.
 */

export interface ClientGeneratorOptions {
  /** Project name */
  projectName: string;
  /** IDL content (if available) */
  idlContent?: string;
  /** WASM file path (relative) */
  wasmPath?: string;
}

/**
 * Generate package.json for the client
 */
export function generatePackageJson(projectName: string): string {
  return JSON.stringify(
    {
      name: `${projectName}-client`,
      version: '0.1.0',
      description: `TypeScript client for ${projectName} Vara program`,
      type: 'module',
      main: './dist/index.js',
      types: './dist/index.d.ts',
      scripts: {
        build: 'tsc',
        dev: 'tsc --watch',
      },
      dependencies: {
        '@gear-js/api': '^0.38.0',
        '@polkadot/api': '^10.11.0',
        '@polkadot/util': '^12.6.0',
        '@polkadot/util-crypto': '^12.6.0',
      },
      devDependencies: {
        typescript: '^5.3.0',
        '@types/node': '^20.11.0',
      },
    },
    null,
    2
  );
}

/**
 * Generate tsconfig.json for the client
 */
export function generateTsConfig(): string {
  return JSON.stringify(
    {
      compilerOptions: {
        target: 'ES2022',
        module: 'ESNext',
        moduleResolution: 'bundler',
        lib: ['ES2022'],
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        declaration: true,
        declarationMap: true,
        outDir: './dist',
        rootDir: './src',
      },
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist'],
    },
    null,
    2
  );
}

/**
 * Generate the main client code
 */
export function generateClientCode(options: ClientGeneratorOptions): string {
  const { projectName, wasmPath } = options;
  
  // Convert project name to PascalCase for class name
  const className = projectName
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');

  return `/**
 * TypeScript client for ${projectName} Vara program
 * 
 * Generated by vara-mcp
 * 
 * Usage:
 *   import { ${className}Client } from './${projectName}-client';
 *   
 *   const client = new ${className}Client();
 *   await client.connect('wss://testnet.vara.network');
 *   
 *   // Upload program (requires seed phrase)
 *   const programId = await client.uploadProgram('./path/to/program.wasm');
 *   
 *   // Or connect to existing program
 *   client.setProgramId('0x...');
 *   
 *   // Send message
 *   await client.sendMessage({ Counter: { Increment: null } });
 *   
 *   // Read state
 *   const state = await client.readState();
 */

import { GearApi, GearKeyring, ProgramMetadata } from '@gear-js/api';
import { readFileSync } from 'node:fs';

/**
 * Connection options
 */
export interface ConnectOptions {
  /** WebSocket endpoint URL */
  endpoint: string;
  /** Connection timeout in ms */
  timeout?: number;
}

/**
 * Upload options
 */
export interface UploadOptions {
  /** Path to the WASM file */
  wasmPath: string;
  /** Optional IDL/metadata path */
  idlPath?: string;
  /** Initial payload for program */
  initPayload?: unknown;
  /** Gas limit (auto-calculated if not provided) */
  gasLimit?: bigint;
  /** Program value */
  value?: bigint;
}

/**
 * Message options
 */
export interface MessageOptions {
  /** Payload to send */
  payload: unknown;
  /** Gas limit (auto-calculated if not provided) */
  gasLimit?: bigint;
  /** Message value */
  value?: bigint;
}

/**
 * ${className} program client
 */
export class ${className}Client {
  private api: GearApi | null = null;
  private programId: string | null = null;
  private keyring: GearKeyring | null = null;
  private metadata: ProgramMetadata | null = null;

  /**
   * Connect to a Vara node
   */
  async connect(endpoint: string = 'wss://testnet.vara.network'): Promise<void> {
    this.api = await GearApi.create({ providerAddress: endpoint });
    console.log(\`Connected to \${endpoint}\`);
    console.log(\`Genesis: \${this.api.genesisHash.toHex()}\`);
  }

  /**
   * Disconnect from the node
   */
  async disconnect(): Promise<void> {
    if (this.api) {
      await this.api.disconnect();
      this.api = null;
    }
  }

  /**
   * Set the program ID to interact with
   */
  setProgramId(programId: string): void {
    this.programId = programId;
  }

  /**
   * Get the current program ID
   */
  getProgramId(): string | null {
    return this.programId;
  }

  /**
   * Initialize keyring from seed phrase
   * 
   * SECURITY: The seed phrase should come from environment variables,
   * never hardcoded or logged.
   */
  async initKeyring(seedPhrase: string): Promise<string> {
    this.keyring = await GearKeyring.fromSuri(seedPhrase);
    const address = this.keyring.address;
    console.log(\`Keyring initialized: \${address}\`);
    return address;
  }

  /**
   * Upload a program to the network
   */
  async uploadProgram(options: UploadOptions): Promise<string> {
    if (!this.api) {
      throw new Error('Not connected. Call connect() first.');
    }
    if (!this.keyring) {
      throw new Error('Keyring not initialized. Call initKeyring() first.');
    }

    // Read WASM file
    const code = readFileSync(options.wasmPath);
    
    // Read metadata if provided
    if (options.idlPath) {
      const idlContent = readFileSync(options.idlPath, 'utf-8');
      this.metadata = ProgramMetadata.from(idlContent);
    }

    // Calculate gas if not provided
    const gasLimit = options.gasLimit ?? await this.api.program.calculateGas.initUpload(
      this.keyring.address,
      code,
      options.initPayload ?? null,
      options.value ?? 0n
    ).then(result => result.min_limit);

    // Create program upload
    const program = {
      code,
      gasLimit,
      value: options.value ?? 0n,
      initPayload: options.initPayload ?? null,
    };

    // Upload and wait for finalization
    const { programId } = await new Promise<{ programId: string }>((resolve, reject) => {
      this.api!.program.upload(program, this.metadata ?? undefined)
        .signAndSend(this.keyring!, ({ events, status }) => {
          if (status.isFinalized) {
            const programEvent = events.find(({ event }) => 
              event.section === 'gear' && event.method === 'ProgramChanged'
            );
            if (programEvent) {
              // Extract program ID from event
              const programId = programEvent.event.data[0].toString();
              resolve({ programId });
            } else {
              reject(new Error('Program upload failed: no ProgramChanged event'));
            }
          }
        })
        .catch(reject);
    });

    this.programId = programId;
    console.log(\`Program uploaded: \${programId}\`);
    return programId;
  }

  /**
   * Send a message to the program
   */
  async sendMessage(options: MessageOptions): Promise<string> {
    if (!this.api) {
      throw new Error('Not connected. Call connect() first.');
    }
    if (!this.keyring) {
      throw new Error('Keyring not initialized. Call initKeyring() first.');
    }
    if (!this.programId) {
      throw new Error('Program ID not set. Call setProgramId() or uploadProgram() first.');
    }

    // Calculate gas if not provided
    const gasLimit = options.gasLimit ?? await this.api.program.calculateGas.handle(
      this.keyring.address,
      this.programId,
      options.payload,
      options.value ?? 0n
    ).then(result => result.min_limit);

    // Create message
    const message = {
      destination: this.programId,
      payload: options.payload,
      gasLimit,
      value: options.value ?? 0n,
    };

    // Send and wait for finalization
    const messageId = await new Promise<string>((resolve, reject) => {
      this.api!.message.send(message, this.metadata ?? undefined)
        .signAndSend(this.keyring!, ({ events, status }) => {
          if (status.isFinalized) {
            const messageEvent = events.find(({ event }) =>
              event.section === 'gear' && event.method === 'MessageQueued'
            );
            if (messageEvent) {
              const messageId = messageEvent.event.data[0].toString();
              resolve(messageId);
            } else {
              reject(new Error('Message send failed: no MessageQueued event'));
            }
          }
        })
        .catch(reject);
    });

    console.log(\`Message sent: \${messageId}\`);
    return messageId;
  }

  /**
   * Read program state
   */
  async readState<T = unknown>(stateQuery?: unknown): Promise<T> {
    if (!this.api) {
      throw new Error('Not connected. Call connect() first.');
    }
    if (!this.programId) {
      throw new Error('Program ID not set. Call setProgramId() or uploadProgram() first.');
    }

    const state = await this.api.programState.read(
      { programId: this.programId, payload: stateQuery ?? null },
      this.metadata ?? undefined
    );

    return state.toJSON() as T;
  }

  /**
   * Get program metadata
   */
  getMetadata(): ProgramMetadata | null {
    return this.metadata;
  }

  /**
   * Load metadata from IDL file
   */
  loadMetadata(idlPath: string): void {
    const idlContent = readFileSync(idlPath, 'utf-8');
    this.metadata = ProgramMetadata.from(idlContent);
  }
}

// Default export for convenience
export default ${className}Client;

// Example usage (uncomment to test)
/*
async function main() {
  const client = new ${className}Client();
  
  // Connect to testnet
  await client.connect('wss://testnet.vara.network');
  
  // Initialize keyring from environment variable
  const seed = process.env.VARA_SEED;
  if (!seed) {
    throw new Error('VARA_SEED environment variable not set');
  }
  await client.initKeyring(seed);
  
  // Upload program
  const programId = await client.uploadProgram({
    wasmPath: '${wasmPath || './program.opt.wasm'}',
    idlPath: './program.idl',
    initPayload: null,
  });
  
  console.log('Program ID:', programId);
  
  // Send a message (example for counter)
  await client.sendMessage({
    payload: { Counter: { Increment: null } },
  });
  
  // Read state
  const state = await client.readState();
  console.log('State:', state);
  
  await client.disconnect();
}

main().catch(console.error);
*/
`;
}

/**
 * Generate a README for the client
 */
export function generateClientReadme(projectName: string): string {
  const className = projectName
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');

  return `# ${projectName}-client

TypeScript client for the ${projectName} Vara program.

## Installation

\`\`\`bash
npm install
\`\`\`

## Build

\`\`\`bash
npm run build
\`\`\`

## Usage

\`\`\`typescript
import { ${className}Client } from './${projectName}-client';

async function main() {
  const client = new ${className}Client();
  
  // Connect to Vara testnet
  await client.connect('wss://testnet.vara.network');
  
  // Initialize keyring (seed from environment)
  await client.initKeyring(process.env.VARA_SEED!);
  
  // Upload program
  const programId = await client.uploadProgram({
    wasmPath: './path/to/program.opt.wasm',
    idlPath: './path/to/program.idl',
  });
  
  // Or connect to existing program
  // client.setProgramId('0x...');
  
  // Send message
  await client.sendMessage({
    payload: { /* your payload */ },
  });
  
  // Read state
  const state = await client.readState();
  console.log('State:', state);
  
  await client.disconnect();
}

main().catch(console.error);
\`\`\`

## Environment Variables

- \`VARA_SEED\`: Your account seed phrase for signing transactions

## API Reference

### \`${className}Client\`

#### Methods

- \`connect(endpoint?: string)\`: Connect to a Vara node
- \`disconnect()\`: Disconnect from the node
- \`initKeyring(seed: string)\`: Initialize signing keypair
- \`uploadProgram(options)\`: Upload WASM program
- \`sendMessage(options)\`: Send message to program
- \`readState(query?)\`: Read program state
- \`setProgramId(id)\`: Set program ID to interact with
- \`loadMetadata(path)\`: Load IDL metadata

## Security

- Never commit seed phrases to version control
- Always use environment variables for sensitive data
- Consider using a hardware wallet for production
`;
}

/**
 * Generate all client files
 */
export function generateClientFiles(options: ClientGeneratorOptions): Record<string, string> {
  return {
    'package.json': generatePackageJson(options.projectName),
    'tsconfig.json': generateTsConfig(),
    'src/index.ts': generateClientCode(options),
    'README.md': generateClientReadme(options.projectName),
  };
}
